# 01｜CLI & Compiler：让列车发车

这一章关注“如何把构建流程跑起来”。可以把 TinyPack 想成一列按站启程的列车：CLI 负责鸣笛出发，Compiler 控制站点广播，而 HookSystem 就是可以插播信息的扩音器。

## 需要完成的能力
1. **CLI 入口**：`bin/tinypack.js` 读取配置并启动构建。
2. **Compiler 生命周期**：实现 `run → compilation → emit → done` 四个阶段。
3. **HookSystem**：用 `tapable` 暴露同步/异步钩子，给插件提供插入点。

## 关键概念 + 类比
- **CLI（命令行入口）**：像检票口，统一读取 `tinypack.config.js` 并实例化 Compiler。
- **Compiler**：调度员，负责按顺序触发各个阶段，并在合适的时间调用插件。
- **HookSystem**：扩音器，由 `tapable` 的 `SyncHook` 和 `AsyncSeriesHook` 组成，外部插件在这里“上麦”。

## 实现要点
### 1. CLI 脚本
```js
#!/usr/bin/env node
const path = require('path');
const config = require(path.resolve(process.cwd(), 'examples/tinypack.config.js'));
const Compiler = require('../core/Compiler');

new Compiler(config).run();
```

### 2. Compiler.run
```js
class Compiler {
  constructor(config) {
    this.config = config;
    this.hooks = new HookSystem().hooks;
    (config.plugins || []).forEach((plugin) => plugin.apply(this));
  }

  async run() {
    this.hooks.run.call();
    const compilation = new Compilation(this.config);
    await compilation.build();
    await this.hooks.emit.promise();
    const outputFile = path.join(this.config.output.path, this.config.output.filename);
    fs.writeFileSync(outputFile, compilation.bundleCode, 'utf-8');
    this.hooks.done.call();
  }
}
```
- `run.call()`：广播“列车即将发车”。
- `Compilation.build()`：下一章重点，负责收集模块。
- `emit.promise()`：在写文件前给插件异步处理的机会。
- `done.call()`：宣告到站。

### 3. HookSystem
```js
class HookSystem {
  constructor() {
    this.hooks = {
      run: new SyncHook(),
      emit: new AsyncSeriesHook(),
      done: new SyncHook(),
    };
  }
}
```
只保留最核心的三个节点，让流程清晰又易扩展。

## 验证方式
```bash
node bin/tinypack.js
```
如果能看到插件打印的 run/emit/done 日志，并且生成了 `dist/bundle.js`，说明列车已成功发车。
