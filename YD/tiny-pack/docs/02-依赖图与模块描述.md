# 02｜Compilation：绘制依赖路线图

在列车比喻里，Compilation 像是“路线规划员”。它需要从入口站出发，沿着 `import` 线索把所有车厢（模块）串起来，并为后续打包阶段准备好统一的模块描述。

## 需要完成的能力
1. **从入口展开依赖图**：`build()` 遍历所有模块，避免重复收集。
2. **标准化模块描述**：每个模块都要输出 `{ filename, code, deps }`。
3. **执行 loader + parser**：保证源码在进入依赖图前已经过转换。

## 类比解释 + 专业说明
- **入口文件**：旅程的起点，`this.config.entry`。
- **循环扫描**：像在站点列表上不断追加新站，直到没有新的依赖。
- **模块描述**：Module Record，记录文件的相对标识、转换后的代码、依赖列表。

## 实现要点
### 1. build()
```js
async build() {
  const entryModule = await this.buildModule(this.config.entry);
  this.modules.push(entryModule);

  for (const mod of this.modules) {
    for (const dep of mod.deps) {
      if (!this.modules.find((m) => m.filename === dep)) {
        const depAbsPath = path.resolve(process.cwd(), dep);
        const depModule = await this.buildModule(depAbsPath);
        this.modules.push(depModule);
      }
    }
  }

  this.bundleCode = bundler(this.modules, entryModule.filename);
}
```
- 通过遍历 `this.modules` 并在循环中 `push` 新模块，实现简易 BFS。
- 构建结束后，把模块列表交给 `bundler`，并传入入口文件名。

### 2. buildModule
```js
async buildModule(filename) {
  let source = fs.readFileSync(filename, 'utf-8');
  const relId = './' + path.relative(process.cwd(), filename).replace(/\\/g, '/');

  const { rules } = this.config.module || {};
  if (rules) {
    for (const rule of rules) {
      if (rule.test.test(filename)) {
        const runner = new LoaderRunner(rule.use);
        source = await runner.runLoaders(source);
      }
    }
  }

  const parser = new Parser();
  const { transformedCode, deps } = parser.parse(source, path.dirname(filename));

  return { filename: relId, code: transformedCode, deps };
}
```
- **LoaderRunner**：保证 `.md`、`.css` 等资源先被转换。
- **Parser**：负责把 ESM 语法转成 CommonJS，并统计依赖。
- **relId**：使用 `./` 开头的相对路径，运行时更容易匹配。

## 验证方式
1. 在 `build()` 结束前 `console.log(this.modules);`，检查是否把所有文件收集齐。
2. 运行 `node bin/tinypack.js`，确认没有“缺失模块”或循环依赖错误，说明依赖图构建成功。
